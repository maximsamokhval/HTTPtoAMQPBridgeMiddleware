# Примеры кода на языке 1С (BSL) для работы с RMQ Middleware

## Обзор

Данный документ содержит примеры кода на языке 1С (BSL), демонстрирующие использование HTTP-интерфейса RMQ Middleware для взаимодействия с RabbitMQ. Примеры основаны на стиле и паттернах из библиотеки [КоннекторHTTP](https://github.com/vbondarevsky/Connector).

## Предварительные требования

1. Установленный и настроенный RMQ Middleware (доступен по URL, например `http://localhost:8000`)
2. Подключенная внешняя компонента или библиотека КоннекторHTTP для выполнения HTTP-запросов
3. Учетные данные для доступа к RabbitMQ

## Структура примеров

Примеры организованы в виде готовых к использованию функций, которые можно включить в общий модуль вашей конфигурации 1С.

### 1. Базовый модуль для работы с RMQ Middleware

```bsl
// BSLLS-off
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда

#Область ПрограммныйИнтерфейс

// Отправляет сообщение в RabbitMQ через RMQ Middleware
//
// Параметры:
//  БазовыйURL - Строка - Базовый URL RMQ Middleware (например, "http://localhost:8000")
//  Пользователь - Строка - Имя пользователя для аутентификации в RabbitMQ
//  Пароль - Строка - Пароль для аутентификации в RabbitMQ
//  Обменник - Строка - Имя обменника (exchange) в RabbitMQ
//  КлючМаршрутизации - Строка - Ключ маршрутизации (routing key)
//  Тело - Любое - Тело сообщения (структура или строка)
//  Заголовки - Соответствие - Дополнительные заголовки AMQP (необязательно)
//  Постоянное - Булево - Сохранять ли сообщение на диск (по умолчанию Истина)
//  Обязательное - Булево - Возвращать ли сообщение при невозможности маршрутизации (по умолчанию Истина)
//  ИдентификаторСообщения - Строка - Уникальный идентификатор сообщения (необязательно)
//  ИдентификаторКорреляции - Строка - Идентификатор корреляции для связывания запросов (необязательно)
//  Приоритет - Число - Приоритет сообщения от 0 до 255 (по умолчанию 0)
//
// Возвращает:
//  Структура - Результат публикации с полями:
//   * Статус - Строка - "accepted" при успехе
//   * ИдентификаторЗапроса - Строка - Идентификатор запроса
//   * Обменник - Строка - Имя обменника
//   * КлючМаршрутизации - Строка - Ключ маршрутизации
//   * ИдентификаторСообщения - Строка - Идентификатор сообщения (если был указан)
//   * ИдентификаторКорреляции - Строка - Идентификатор корреляции
//
// Исключения:
//  Вызывает исключение при ошибке сети, аутентификации или валидации
//
Функция ОпубликоватьСообщение(
	БазовыйURL,
	Пользователь,
	Пароль,
	Обменник,
	КлючМаршрутизации,
	Тело,
	Заголовки = Неопределено,
	Постоянное = Истина,
	Обязательное = Истина,
	ИдентификаторСообщения = Неопределено,
	ИдентификаторКорреляции = Неопределено,
	Приоритет = 0) Экспорт
	
	URL = БазовыйURL + "/v1/publish";
	
	// Подготовка тела запроса
	Запрос = Новый Структура;
	Запрос.Вставить("exchange", Обменник);
	Запрос.Вставить("routing_key", КлючМаршрутизации);
	Запрос.Вставить("payload", Тело);
	Запрос.Вставить("mandatory", Обязательное);
	Запрос.Вставить("persistence", ?(Постоянное, 2, 1)); // 2 = PERSISTENT, 1 = TRANSIENT
	
	Если Заголовки <> Неопределено Тогда
		Запрос.Вставить("headers", Заголовки);
	КонецЕсли;
	
	Если ИдентификаторСообщения <> Неопределено Тогда
		Запрос.Вставить("message_id", ИдентификаторСообщения);
	КонецЕсли;
	
	Если ИдентификаторКорреляции <> Неопределено Тогда
		Запрос.Вставить("correlation_id", ИдентификаторКорреляции);
	КонецЕсли;
	
	Если Приоритет > 0 Тогда
		Запрос.Вставить("priority", Приоритет);
	КонецЕсли;
	
	// Настройки аутентификации
	Аутентификация = Новый Структура("Пользователь, Пароль", Пользователь, Пароль);
	ДополнительныеПараметры = Новый Структура("Аутентификация", Аутентификация);
	
	Попытка
		Ответ = КоннекторHTTP.PostJson(URL, Запрос, ДополнительныеПараметры);
		Возврат Ответ;
	Исключение
		Информация = ИнформацияОбОшибке();
		// Преобразование HTTP ошибок в понятные исключения
		Если СтрНайти(Информация.Описание, "401") > 0 Тогда
			ВызватьИсключение "Ошибка аутентификации: неверные учетные данные RabbitMQ";
		ИначеЕсли СтрНайти(Информация.Описание, "503") > 0 Тогда
			ВызватьИсключение "Сервис RabbitMQ недоступен";
		ИначеЕсли СтрНайти(Информация.Описание, "504") > 0 Тогда
			ВызватьИсключение "Таймаут публикации сообщения";
		ИначеЕсли СтрНайти(Информация.Описание, "400") > 0 Тогда
			ВызватьИсключение "Ошибка валидации: " + Информация.Описание;
		Иначе
			ВызватьИсключение "Ошибка при публикации сообщения: " + Информация.Описание;
		КонецЕсли;
	КонецПопытки;
	
КонецФункции

// Получает одно сообщение из очереди RabbitMQ через RMQ Middleware
//
// Параметры:
//  БазовыйURL - Строка - Базовый URL RMQ Middleware
//  Пользователь - Строка - Имя пользователя для аутентификации в RabbitMQ
//  Пароль - Строка - Пароль для аутентификации в RabbitMQ
//  Очередь - Строка - Имя очереди для потребления
//  Таймаут - Число - Время ожидания сообщения в секундах (по умолчанию 30)
//  АвтоПодтверждение - Булево - Автоматически подтверждать сообщение при получении (по умолчанию Ложь)
//
// Возвращает:
//  Структура - Сообщение с полями:
//   * delivery_tag - Число - Идентификатор доставки для подтверждения
//   * body - Любое - Тело сообщения (структура или строка)
//   * routing_key - Строка - Ключ маршрутизации
//   * exchange - Строка - Имя обменника
//   * correlation_id - Строка - Идентификатор корреляции
//   * headers - Соответствие - Заголовки AMQP
//   * redelivered - Булево - Флаг повторной доставки
//  Неопределено - Если сообщений нет в течение таймаута
//
// Исключения:
//  Вызывает исключение при ошибке сети, аутентификации или валидации
//
Функция ПолучитьСообщение(
	БазовыйURL,
	Пользователь,
	Пароль,
	Очередь,
	Таймаут = 30,
	АвтоПодтверждение = Ложь) Экспорт
	
	URL = БазовыйURL + "/v1/fetch";
	
	// Подготовка тела запроса
	Запрос = Новый Структура;
	Запрос.Вставить("queue", Очередь);
	Запрос.Вставить("timeout", Таймаут);
	Запрос.Вставить("auto_ack", АвтоПодтверждение);
	
	// Настройки аутентификации
	Аутентификация = Новый Структура("Пользователь, Пароль", Пользователь, Пароль);
	ДополнительныеПараметры = Новый Структура("Аутентификация", Аутентификация);
	
	Попытка
		Ответ = КоннекторHTTP.PostJson(URL, Запрос, ДополнительныеПараметры);
		
		// Если статус 204 - нет сообщений
		Если Ответ.КодСостояния = 204 Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Возврат Ответ;
	Исключение
		Информация = ИнформацияОбОшибке();
		// Преобразование HTTP ошибок в понятные исключения
		Если СтрНайти(Информация.Описание, "401") > 0 Тогда
			ВызватьИсключение "Ошибка аутентификации: неверные учетные данные RabbitMQ";
		ИначеЕсли СтрНайти(Информация.Описание, "503") > 0 Тогда
			ВызватьИсключение "Сервис RabbitMQ недоступен";
		ИначеЕсли СтрНайти(Информация.Описание, "400") > 0 Тогда
			ВызватьИсключение "Ошибка валидации: " + Информация.Описание;
		Иначе
			ВызватьИсключение "Ошибка при получении сообщения: " + Информация.Описание;
		КонецЕсли;
	КонецПопытки;
	
КонецФункции

// Подтверждает успешную обработку сообщения
//
// Параметры:
//  БазовыйURL - Строка - Базовый URL RMQ Middleware
//  Пользователь - Строка - Имя пользователя для аутентификации в RabbitMQ
//  Пароль - Строка - Пароль для аутентификации в RabbitMQ
//  ИдентификаторДоставки - Число - Идентификатор доставки (delivery_tag) из полученного сообщения
//
// Возвращает:
//  Булево - Истина, если подтверждение успешно
//
// Исключения:
//  Вызывает исключение при ошибке сети, аутентификации или неверном идентификаторе
//
Функция ПодтвердитьСообщение(
	БазовыйURL,
	Пользователь,
	Пароль,
	ИдентификаторДоставки) Экспорт
	
	URL = БазовыйURL + "/v1/ack/" + ИдентификаторДоставки;
	
	// Настройки аутентификации
	Аутентификация = Новый Структура("Пользователь, Пароль", Пользователь, Пароль);
	ДополнительныеПараметры = Новый Структура("Аутентификация", Аутентификация);
	
	Попытка
		Ответ = КоннекторHTTP.PostJson(URL, Неопределено, ДополнительныеПараметры);
		Возврат Истина;
	Исключение
		Информация = ИнформацияОбОшибке();
		// Преобразование HTTP ошибок в понятные исключения
		Если СтрНайти(Информация.Описание, "401") > 0 Тогда
			ВызватьИсключение "Ошибка аутентификации: неверные учетные данные RabbitMQ";
		ИначеЕсли СтрНайти(Информация.Описание, "503") > 0 Тогда
			ВызватьИсключение "Сервис RabbitMQ недоступен";
		ИначеЕсли СтрНайти(Информация.Описание, "400") > 0 Тогда
			ВызватьИсключение "Неверный идентификатор доставки: " + ИдентификаторДоставки;
		Иначе
			ВызватьИсключение "Ошибка при подтверждении сообщения: " + Информация.Описание;
		КонецЕсли;
	КонецПопытки;
	
КонецФункции

// Отклоняет сообщение с возможностью возврата в очередь
//
// Параметры:
//  БазовыйURL - Строка - Базовый URL RMQ Middleware
//  Пользователь - Строка - Имя пользователя для аутентификации в RabbitMQ
//  Пароль - Строка - Пароль для аутентификации в RabbitMQ
//  ИдентификаторДоставки - Число - Идентификатор доставки (delivery_tag) из полученного сообщения
//  ВернутьВОчередь - Булево - Вернуть ли сообщение в очередь (по умолчанию Ложь)
//
// Возвращает:
//  Булево - Истина, если отклонение успешно
//
// Исключения:
//  Вызывает исключение при ошибке сети, аутентификации или неверном идентификаторе
//
Функция ОтклонитьСообщение(
	БазовыйURL,
	Пользователь,
	Пароль,
	ИдентификаторДоставки,
	ВернутьВОчередь = Ложь) Экспорт
	
	URL = БазовыйURL + "/v1/reject/" + ИдентификаторДоставки;
	
	// Тело запроса для указания флага requeue
	Запрос = Новый Структура("requeue", ВернутьВОчередь);
	
	// Настройки аутентификации
	Аутентификация = Новый Структура("Пользователь, Пароль", Пользователь, Пароль);
	ДополнительныеПараметры = Новый Структура("Аутентификация", Аутентификация);
	
	Попытка
		Ответ = КоннекторHTTP.PostJson(URL, Запрос, ДополнительныеПараметры);
		Возврат Истина;
	Исключение
		Информация = ИнформацияОбОшибке();
		// Преобразование HTTP ошибок в понятные исключения
		Если СтрНайти(Информация.Описание, "401") > 0 Тогда
			ВызватьИсключение "Ошибка аутентификации: неверные учетные данные RabbitMQ";
		ИначеЕсли СтрНайти(Информация.Описание, "503") > 0 Тогда
			ВызватьИсключение "Сервис RabbitMQ недоступен";
		ИначеЕсли СтрНайти(Информация.Описание, "400") > 0 Тогда
			ВызватьИсключение "Неверный идентификатор доставки: " + ИдентификаторДоставки;
		Иначе
			ВызватьИсключение "Ошибка при отклонении сообщения: " + Информация.Описание;
		КонецЕсли;
	КонецПопытки;
	
КонецФункции

// Проверяет доступность RMQ Middleware
//
// Параметры:
//  БазовыйURL - Строка - Базовый URL RMQ Middleware
//
// Возвращает:
//  Структура - Результат проверки здоровья с полями:
//   * status - Строка - "healthy" или "unhealthy"
//   * service - Строка - "rmq-middleware"
//
Функция ПроверитьЗдоровье(БазовыйURL) Экспорт
	
	URL = БазовыйURL + "/health";
	
	Попытка
		Ответ = КоннекторHTTP.GetJson(URL);
		Возврат Ответ;
	Исключение
		// В случае ошибки считаем сервис недоступным
		Возврат Новый Структура("status, service", "unhealthy", "rmq-middleware");
	КонецПопытки;
	
КонецФункции

// Проверяет готовность RMQ Middleware к работе (подключение к RabbitMQ)
//
// Параметры:
//  БазовыйURL - Строка - Базовый URL RMQ Middleware
//
// Возвращает:
//  Структура - Результат проверки готовности с полями:
//   * status - Строка - "ready" или "not ready"
//   * service - Строка - "rmq-middleware"
//   * amqp_connected - Булево - Подключен ли к RabbitMQ
//   * amqp_ready - Булево - Готов ли к работе
//   * amqp_state - Строка - Состояние подключения
//   * pending_messages - Число - Количество ожидающих сообщений
//   * active_sessions - Число - Количество активных сессий
//
Функция ПроверитьГотовность(БазовыйURL) Экспорт
	
	URL = БазовыйURL + "/ready";
	
	Попытка
		Ответ = КоннекторHTTP.GetJson(URL);
		Возврат Ответ;
	Исключение
		// В случае ошибки считаем сервис не готовым
		Возврат Новый Структура(
			"status, service, amqp_connected, amqp_ready, amqp_state, pending_messages, active_sessions",
			"not ready", "rmq-middleware", Ложь, Ложь, "disconnected", 0, 0
		);
	КонецПопытки;
	
КонецФункции

#КонецОбласти

#КонецЕсли
```

## Рекомендации по обработке ошибок

### 1. Типичные ошибки и их решение

| Код ошибки | Причина | Рекомендуемые действия |
|------------|---------|------------------------|
| 401 Unauthorized | Неверные учетные данные RabbitMQ | 1. Проверьте логин/пароль<br>2. Убедитесь, что пользователь имеет права на обменник/очередь<br>3. Проверьте настройки виртуального хоста (vhost) |
| 503 Service Unavailable | RabbitMQ недоступен | 1. Проверьте состояние RabbitMQ (`rabbitmqctl status`)<br>2. Проверьте сетевое подключение<br>3. Используйте функции `ПроверитьЗдоровье` и `ПроверитьГотовность` |
| 504 Gateway Timeout | Таймаут публикации | 1. Увеличьте `publish_timeout` в настройках RMQ Middleware<br>2. Проверьте нагрузку на RabbitMQ<br>3. Рассмотрите асинхронную публикацию |
| 400 Bad Request | Ошибка валидации | 1. Проверьте формат имен (только буквы, цифры, точки, дефисы, подчеркивания)<br>2. Убедитесь, что тело сообщения корректно сериализуется в JSON<br>3. Проверьте диапазоны значений (приоритет 0-255, таймаут 0-300) |
| 404 Not Found | Ресурс не найден | 1. Проверьте URL RMQ Middleware<br>2. Убедитесь, что используется правильный путь API (`/v1/...`) |
| 500 Internal Server Error | Внутренняя ошибка сервера | 1. Проверьте логи RMQ Middleware<br>2. Убедитесь, что RabbitMQ доступен и работает корректно<br>3. Проверьте настройки приложения |

### 2. Специальная обработка ошибки "Response content longer than Content-Length"

**Контекст**: Эта ошибка возникает, когда RMQ Middleware успешно публикует сообщение в RabbitMQ, но при отправке HTTP-ответа клиенту возникает несоответствие между фактической длиной тела ответа и заголовком Content-Length.

**Симптомы**:
- Сообщение успешно публикуется в RabbitMQ (видно в логах RabbitMQ)
- Клиент получает ошибку 500 Internal Server Error
- В логах RMQ Middleware видна ошибка: `RuntimeError: Response content longer than Content-Length`

**Причины**:
1. Проблема с кодировкой символов в ответе
2. Ошибка в middleware (например, Prometheus instrumentation)
3. Баг в версиях uvicorn/starlette

**Решение на стороне 1С**:
```bsl
// Улучшенная функция публикации с обработкой специфических ошибок
Функция ОпубликоватьСообщениеСРасширеннойОбработкой(
	БазовыйURL,
	Пользователь,
	Пароль,
	Обменник,
	КлючМаршрутизации,
	Тело,
	Заголовки = Неопределено,
	Постоянное = Истина,
	Обязательное = Истина,
	ИдентификаторСообщения = Неопределено,
	ИдентификаторКорреляции = Неопределено,
	Приоритет = 0) Экспорт
	
	URL = БазовыйURL + "/v1/publish";
	
	// Подготовка тела запроса
	Запрос = Новый Структура;
	Запрос.Вставить("exchange", Обменник);
	Запрос.Вставить("routing_key", КлючМаршрутизации);
	Запрос.Вставить("payload", Тело);
	Запрос.Вставить("mandatory", Обязательное);
	Запрос.Вставить("persistence", ?(Постоянное, 2, 1));
	
	Если Заголовки <> Неопределено Тогда
		Запрос.Вставить("headers", Заголовки);
	КонецЕсли;
	
	Если ИдентификаторСообщения <> Неопределено Тогда
		Запрос.Вставить("message_id", ИдентификаторСообщения);
	КонецЕсли;
	
	Если ИдентификаторКорреляции <> Неопределено Тогда
		Запрос.Вставить("correlation_id", ИдентификаторКорреляции);
	КонецЕсли;
	
	Если Приоритет > 0 Тогда
		Запрос.Вставить("priority", Приоритет);
	КонецЕсли;
	
	// Настройки аутентификации
	Аутентификация = Новый Структура("Пользователь, Пароль", Пользователь, Пароль);
	ДополнительныеПараметры = Новый Структура("Аутентификация", Аутентификация);
	
	Попытка
		Ответ = КоннекторHTTP.PostJson(URL, Запрос, ДополнительныеПараметры);
		Возврат Ответ;
	Исключение
		Информация = ИнформацияОбОшибке();
		ОписаниеОшибки = Информация.Описание;
		
		// Специальная обработка ошибки "Response content longer than Content-Length"
		Если СтрНайти(ОписаниеОшибки, "Response content longer than Content-Length") > 0 Тогда
			// В этом случае сообщение, скорее всего, было успешно опубликовано в RabbitMQ,
			// но возникла техническая проблема при отправке ответа.
			// Можно проверить статус сообщения другими способами или просто считать операцию успешной
			// с записью в журнал для последующего анализа.
			
			ЗаписатьВЖурнал(
				"ВНИМАНИЕ: Техническая ошибка при отправке ответа, но сообщение, вероятно, опубликовано",
				"Обменник: " + Обменник,
				"КлючМаршрутизации: " + КлючМаршрутизации,
				"ИдентификаторКорреляции: " + ИдентификаторКорреляции
			);
			
			// Возвращаем успешный результат, так как сообщение было опубликовано
			Возврат Новый Структура(
				"status, request_id, exchange, routing_key, message_id, correlation_id",
				"accepted", "", Обменник, КлючМаршрутизации, ИдентификаторСообщения, ИдентификаторКорреляции
			);
		КонецЕсли;
		
		// Стандартная обработка других ошибок
		Если СтрНайти(ОписаниеОшибки, "401") > 0 Тогда
			ВызватьИсключение "Ошибка аутентификации: неверные учетные данные RabbitMQ";
		ИначеЕсли СтрНайти(ОписаниеОшибки, "503") > 0 Тогда
			ВызватьИсключение "Сервис RabbitMQ недоступен";
		ИначеЕсли СтрНайти(ОписаниеОшибки, "504") > 0 Тогда
			ВызватьИсключение "Таймаут публикации сообщения";
		ИначеЕсли СтрНайти(ОписаниеОшибки, "400") > 0 Тогда
			ВызватьИсключение "Ошибка валидации: " + ОписаниеОшибки;
		Иначе
			ВызватьИсключение "Ошибка при публикации сообщения: " + ОписаниеОшибки;
		КонецЕсли;
	КонецПопытки;
	
КонецФункции
```

**Рекомендации**:
1. Используйте функцию `ОпубликоватьСообщениеСРасширеннойОбработкой` для критически важных операций
2. Регулярно обновляйте RMQ Middleware до последней версии
3. Мониторьте логи RMQ Middleware на предмет этой ошибки
4. При частом возникновении ошибки сообщите разработчикам RMQ Middleware


### 2. Паттерны устойчивости

#### Повторные попытки (Retry Pattern)
```bsl
Функция ОтправитьСПовторами(Параметры, МаксимальноеКоличествоПопыток = 3)
	
	Для Попытка = 1 По МаксимальноеКоличествоПопыток Цикл
		Попытка
			Возврат ОпубликоватьСообщение(Параметры);
		Исключение
			Если Попытка = МаксимальноеКоличествоПопыток Тогда
				ВызватьИсключение;
			КонецЕсли;
			
			// Экспоненциальная задержка
			Задержка = 1000 * (2 ^ (Попытка - 1)); // 1, 2, 4 секунды
			Ждать(Задержка / 1000);
		КонецПопытки;
	КонецЦикла;
	
КонецФункции
```

#### Circuit Breaker (Автоматический выключатель)
```bsl
// Упрощенная реализация Circuit Breaker
Перем СостояниеВыключателя Экспорт;
Перем ВремяПоследнейОшибки Экспорт;

Функция ОтправитьСCircuitBreaker(Параметры)
	
	// Проверяем состояние выключателя
	Если СостояниеВыключателя = "open" Тогда
		Если ТекущаяДата() - ВремяПоследнейОшибки > 300 Тогда // 5 минут
			СостояниеВыключателя = "half-open";
		Иначе
			ВызватьИсключение "Сервис временно недоступен (circuit breaker open)";
		КонецЕсли;
	КонецЕсли;
	
	Попытка
		Результат = ОпубликоватьСообщение(Параметры);
		
		// Успех - сбрасываем выключатель
		Если СостояниеВыключателя = "half-open" Тогда
			СостояниеВыключателя = "closed";
		КонецЕсли;
		
		Возврат Результат;
	Исключение
		// Ошибка - обновляем состояние
		ВремяПоследнейОшибки = ТекущаяДата();
		Если СостояниеВыключателя = "half-open" Или СостояниеВыключателя = "closed" Тогда
			СостояниеВыключателя = "open";
		КонецЕсли;
		
		ВызватьИсключение;
	КонецПопытки;
	
КонецФункции
```

### 3. Мониторинг и логирование

```bsl
// Расширенная функция с логированием
Функция ОпубликоватьСЛогированием(Параметры)
	
	ИдентификаторОперации = Строка(Новый УникальныйИдентификатор);
	ЗаписатьВЖурнал("Начало публикации", ИдентификаторОперации, Параметры);
	
	НачалоВремени = ТекущаяДата();
	
	Попытка
		Результат = ОпубликоватьСообщение(Параметры);
		
		КонецВремени = ТекущаяДата();
		Длительность = КонецВремени - НачалоВремени;
		
		ЗаписатьВЖурнал("Успешная публикация", ИдентификаторОперации, Результат, Длительность);
		
		Возврат Результат;
	Исключение
		КонецВремени = ТекущаяДата();
		Длительность = КонецВремени - НачалоВремени;
		
		ЗаписатьВЖурнал("Ошибка публикации", ИдентификаторОперации, ОписаниеОшибки(), Длительность);
		
		ВызватьИсключение;
	КонецПопытки;
	
КонецФункции
```

## Архитектурные рекомендации

### 1. Worker-процесс для обработки очередей
```bsl
Процедура ОбработчикОчереди(БазовыйURL, Пользователь, Пароль, Очередь)
	
	Пока Истина Цикл
		
		Попытка
			Сообщение = ПолучитьСообщение(БазовыйURL, Пользователь, Пароль, Очередь, 30, Ложь);
			
			Если Сообщение = Неопределено Тогда
				// Нет сообщений, небольшая пауза перед следующей попыткой
				Ждать(1);
				Продолжить;
			КонецЕсли;
			
			// Обработка сообщения
			Успешно = ОбработатьСообщение(Сообщение);
			
			Если Успешно Тогда
				ПодтвердитьСообщение(БазовыйURL, Пользователь, Пароль, Сообщение.delivery_tag);
			Иначе
				// Отклоняем без возврата в очередь (отправляем в DLQ)
				ОтклонитьСообщение(БазовыйURL, Пользователь, Пароль, Сообщение.delivery_tag, Ложь);
			КонецЕсли;
			
		Исключение
			// Логируем ошибку и продолжаем работу
			ЗаписатьВЖурнал("Ошибка в обработчике очереди", Очередь, ОписаниеОшибки());
			Ждать(5); // Пауза при ошибках
		КонецПопытки;
		
	КонецЦикла;
	
КонецПроцедуры
```

### 2. Публикация с гарантированной доставкой
```bsl
// Сохраняет сообщение в локальную БД перед отправкой
// и периодически пытается отправить неотправленные сообщения
Процедура ОпубликоватьСГарантией(Параметры)
	
	// Сохраняем в локальную таблицу сообщений
	ИдентификаторСообщения = СохранитьВЛокальнуюБД(Параметры);
	
	Попытка
		Результат = ОпубликоватьСообщение(Параметры);
		ПометитьКакОтправленное(ИдентификаторСообщения);
	Исключение
		// Сообщение останется в локальной БД для повторной отправки
		ЗаписатьВЖурнал("Не удалось отправить сообщение, будет повтор", ИдентификаторСообщения);
	КонецПопытки;
	
КонецПроцедуры
```

## Заключение

Представленные примеры кода демонстрируют полный цикл работы с RabbitMQ через RMQ Middleware из среды 1С:Предприятие. Код следует принципам:

1. **Идемпотентность**: Использование `message_id` для предотвращения дублирования
2. **Устойчивость**: Обработка сетевых ошибок и автоматические повторные попытки
3. **Наблюдаемость**: Логирование и мониторинг всех операций
4. **Производительность**: Пакетная обработка и асинхронные операции

Для интеграции в вашу конфигурацию:
1. Скопируйте функции из раздела "Базовый модуль" в общий модуль
2. Настройте параметры подключения (URL, учетные данные)
3. Реализуйте бизнес-логику обработки сообщений
4. Добавьте мониторинг и обработку ошибок согласно вашим требованиям

## Дополнительные ресурсы

1. [Документация RMQ Middleware](https://github.com/your-org/rmq-middleware)
2. [Библиотека КоннекторHTTP](https://github.com/vbondarevsky/Connector)
3. [RabbitMQ Best Practices](https://www.rabbitmq.com/documentation.html)
4. [1С:Предприятие - Работа с HTTP](https://its.1c.ru/db/v8316doc#bookmark:dev:TI000001367)

### 2. Примеры использования функций

Ниже приведены практические примеры использования созданных функций в различных сценариях.

```bsl
// BSLLS-off
#Если Сервер Тогда

// Пример 1: Публикация сообщения в RabbitMQ
Процедура Пример_ПубликацияСообщения() Экспорт
	
	БазовыйURL = "http://localhost:8000";
	Пользователь = "guest";
	Пароль = "guest";
	Обменник = "amq.topic";
	КлючМаршрутизации = "orders.new";
	
	// Тело сообщения в формате JSON (структура)
	ТелоСообщения = Новый Структура;
	ТелоСообщения.Вставить("order_id", "ORD-2024-001");
	ТелоСообщения.Вставить("customer", "Иванов Иван");
	ТелоСообщения.Вставить("amount", 15000);
	ТелоСообщения.Вставить("currency", "RUB");
	ТелоСообщения.Вставить("timestamp", ТекущаяДата());
	
	// Дополнительные заголовки
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("source", "1c-enterprise");
	Заголовки.Вставить("version", "1.0");
	
	Попытка
		Результат = ОпубликоватьСообщение(
			БазовыйURL,
			Пользователь,
			Пароль,
			Обменник,
			КлючМаршрутизации,
			ТелоСообщения,
			Заголовки,
			Истина,  // Постоянное сообщение
			Истина,  // Обязательное
			"msg-" + Строка(Новый УникальныйИдентификатор),  // Идентификатор сообщения
			"corr-" + Строка(Новый УникальныйИдентификатор), // Идентификатор корреляции
			5        // Приоритет
		);
		
		Сообщить("Сообщение успешно опубликовано:");
		Сообщить("  Идентификатор запроса: " + Результат.request_id);
		Сообщить("  Обменник: " + Результат.exchange);
		Сообщить("  Ключ маршрутизации: " + Результат.routing_key);
		Сообщить("  Идентификатор корреляции: " + Результат.correlation_id);
		
	Исключение
		Сообщить("Ошибка при публикации сообщения: " + ОписаниеОшибки());
	КонецПопытки;
	
КонецПроцедуры

// Пример 2: Получение и обработка сообщений из очереди
Процедура Пример_ПолучениеИОбработкаСообщений() Экспорт
	
	БазовыйURL = "http://localhost:8000";
	Пользователь = "guest";
	Пароль = "guest";
	Очередь = "orders.process";
	
	// Получаем сообщение с таймаутом 10 секунд
	Попытка
		Сообщение = ПолучитьСообщение(
			БазовыйURL,
			Пользователь,
			Пароль,
			Очередь,
			10,      // Таймаут 10 секунд
			Ложь    // Без автоматического подтверждения
		);
		
		Если Сообщение = Неопределено Тогда
			Сообщить("Сообщений в очереди нет");
			Возврат;
		КонецЕсли;
		
		// Обработка сообщения
		Сообщить("Получено сообщение:");
		Сообщить("  Идентификатор доставки: " + Сообщение.delivery_tag);
		Сообщить("  Обменник: " + Сообщение.exchange);
		Сообщить("  Ключ маршрутизации: " + Сообщение.routing_key);
		Сообщить("  Идентификатор корреляции: " + Сообщение.correlation_id);
		Сообщить("  Повторная доставка: " + Сообщение.redelivered);
		
		// Тело сообщения может быть структурой или строкой
		Если ТипЗнч(Сообщение.body) = Тип("Структура") Тогда
			Сообщить("  Тело сообщения (структура):");
			Для Каждого КлючЗначение Из Сообщение.body Цикл
				Сообщить("    " + КлючЗначение.Ключ + ": " + КлючЗначение.Значение);
			КонецЦикла;
		Иначе
			Сообщить("  Тело сообщения: " + Сообщение.body);
		КонецЕсли;
		
		// Обработка бизнес-логики
		УспешноОбработано = ОбработатьЗаказ(Сообщение.body);
		
		Если УспешноОбработано Тогда
			// Подтверждаем успешную обработку
			ПодтвердитьСообщение(БазовыйURL, Пользователь, Пароль, Сообщение.delivery_tag);
			Сообщить("Сообщение успешно обработано и подтверждено");
		Иначе
			// Отклоняем сообщение с возвратом в очередь для повторной обработки
			ОтклонитьСообщение(БазовыйURL, Пользователь, Пароль, Сообщение.delivery_tag, Истина);
			Сообщить("Ошибка обработки, сообщение возвращено в очередь");
		КонецЕсли;
		
	Исключение
		Сообщить("Ошибка при получении/обработке сообщения: " + ОписаниеОшибки());
	КонецПопытки;
	
КонецПроцедуры

// Пример 3: Мониторинг состояния RMQ Middleware
Процедура Пример_МониторингСостояния() Экспорт
	
	БазовыйURL = "http://localhost:8000";
	
	// Проверка здоровья
	Здоровье = ПроверитьЗдоровье(БазовыйURL);
	Сообщить("Проверка здоровья:");
	Сообщить("  Статус: " + Здоровье.status);
	Сообщить("  Сервис: " + Здоровье.service);
	
	// Проверка готовности
	Готовность = ПроверитьГотовность(БазовыйURL);
	Сообщить("Проверка готовности:");
	Сообщить("  Статус: " + Готовность.status);
	Сообщить("  Подключен к RabbitMQ: " + Готовность.amqp_connected);
	Сообщить("  Готов к работе: " + Готовность.amqp_ready);
	Сообщить("  Состояние: " + Готовность.amqp_state);
	Сообщить("  Ожидающих сообщений: " + Готовность.pending_messages);
	Сообщить("  Активных сессий: " + Готовность.active_sessions);
	
	Если Не Готовность.amqp_ready Тогда
		Сообщить("ВНИМАНИЕ: RMQ Middleware не готов к работе!");
		// Можно отправить уведомление администратору
	КонецЕсли;
	
КонецПроцедуры

// Пример 4: Пакетная обработка сообщений
Процедура Пример_ПакетнаяОбработка() Экспорт
	
	БазовыйURL = "http://localhost:8000";
	Пользователь = "guest";
	Пароль = "guest";
	Очередь = "orders.batch";
	
	МаксимальноеКоличествоСообщений = 100;
	СообщенияДляПодтверждения = Новый Массив;
	
	Для Счетчик = 1 По МаксимальноеКоличествоСообщений Цикл
		
		// Получаем сообщение без ожидания (таймаут 0)
		Сообщение = ПолучитьСообщение(
			БазовыйURL,
			Пользователь,
			Пароль,
			Очередь,
			0,      // Таймаут 0 - немедленный возврат
			Ложь   // Без автоматического подтверждения
		);
		
		Если Сообщение = Неопределено Тогда
			// Больше нет сообщений
			Прервать;
		КонецЕсли;
		
		// Обработка сообщения
		Успешно = ОбработатьСообщениеВПакете(Сообщение);
		
		Если Успешно Тогда
			// Сохраняем для последующего подтверждения
			СообщенияДляПодтверждения.Добавить(Сообщение.delivery_tag);
		Иначе
			// Немедленно отклоняем проблемные сообщения
			ОтклонитьСообщение(БазовыйURL, Пользователь, Пароль, Сообщение.delivery_tag, Ложь);
		КонецЕсли;
		
	КонецЦикла;
	
	// Подтверждаем все успешно обработанные сообщения
	Для Каждого ИдентификаторДоставки Из СообщенияДляПодтверждения Цикл
		ПодтвердитьСообщение(БазовыйURL, Пользователь, Пароль, ИдентификаторДоставки);
	КонецЦикла;
	
	Сообщить("Обработано сообщений: " + СообщенияДляПодтверждения.Количество());
	
КонецПроцедуры

// Пример 5: Обработка с повторными попытками при ошибках сети
Процедура Пример_ОбработкаСПовторами() Экспорт
	
	БазовыйURL = "http://localhost:8000";
	Пользователь = "guest";
	Пароль = "guest";
	Очередь = "orders.resilient";
	
	МаксимальноеКоличествоПопыток = 3;
	
	Для Попытка = 1 По МаксимальноеКоличествоПопыток Цикл
		
		Попытка
			// Публикация сообщения с повышенным приоритетом
			Тело = Новый Структура("attempt, timestamp", Попытка, ТекущаяДата());
			
			Результат = ОпубликоватьСообщение(
				БазовыйURL,
				Пользователь,
				Пароль,
				"amq.topic",
				"orders.retry",
				Тело,
				Неопределено, // Без заголовков
				Истина,       // Постоянное
				Истина,       // Обязательное
				Неопределено, // Без ID сообщения
				"retry-" + Строка(Попытка), // Идентификатор корреляции
				10            // Высокий приоритет
			);
			
			Сообщить("Сообщение успешно опубликовано с попытки " + Попытка);
			Прервать; // Успех, выходим из цикла
			
		Исключение
			Если Попытка = МаксимальноеКоличествоПопыток Тогда
				Сообщить("Не удалось опубликовать сообщение после " + МаксимальноеКоличествоПопыток + " попыток");
				// Можно записать в журнал или отправить уведомление
				ВызватьИсключение;
			КонецЕсли;
			
			// Ждем перед следующей попыткой (экспоненциальная задержка)
			Задержка = 2 * (2 ^ (Попытка - 1)); // 2, 4, 8 секунд
			Сообщить("Ошибка публикации, повтор через " + Задержка + " секунд...");
			Ждать(Задержка);
		КонецПопытки;
		
	КонецЦикла;
	
КонецПроцедуры

// Вспомогательные функции (заглушки для примеров)
Функция ОбработатьЗаказ(ДанныеЗаказа) Экспорт
	// Реальная бизнес-логика обработки заказа
	// Возвращает Истина при успешной обработке, Ложь при ошибке
	Возврат Истина;
КонецФункции

Функция ОбработатьСообщениеВПакете(Сообщение) Экспорт
	// Обработка сообщения в пакетном режиме
	// Возвращает Истина при успешной обработке
	Возврат Истина;
КонецФункции

#КонецЕсли
```
