# Детализированный план имплементации улучшений RMQ Middleware

## Обзор плана

План разделен на 5 фаз, каждая из которых фокусируется на конкретных улучшениях с четкими критериями завершения. Каждая фаза может быть выполнена независимо, но рекомендуется следовать порядку для минимизации рисков.

## Фаза 1: Критические исправления (1-2 недели)

### Задача 1.1: Исправление KeyError в логировании
**Проблема**: `KeyError: 'request_id'` в логах при фоновых операциях
**Решение**: Модифицировать `get_request_id()` для гарантированного возврата значения

**Шаги реализации:**
1. Анализ текущей реализации `middleware.py`
2. Модификация `get_request_id()` для возврата UUID даже вне контекста запроса
3. Обновление форматеров логов для обработки отсутствующих request_id
4. Добавление тестов для проверки корректности логирования

**Файлы для изменения:**
- `src/rmq_middleware/middleware.py` - функция `get_request_id()`
- `src/rmq_middleware/middleware.py` - функции `text_formatter()` и `json_sink()`
- `tests/test_middleware.py` - новые тесты

**Критерии завершения:**
- Отсутствие KeyError в логах при запуске приложения
- Все тесты проходят
- Логи содержат корректные request_id для всех операций

### Задача 1.2: Circuit Breaker для RabbitMQ операций
**Проблема**: При сбое RabbitMQ приложение продолжает безуспешные попытки
**Решение**: Внедрить паттерн Circuit Breaker

**Шаги реализации:**
1. Выбор библиотеки или реализация собственного Circuit Breaker
2. Интеграция Circuit Breaker в `AMQPClient`
3. Настройка параметров (failure threshold, recovery timeout)
4. Добавление метрик для мониторинга состояния Circuit Breaker

**Файлы для изменения:**
- `src/rmq_middleware/amqp_wrapper.py` - класс `AMQPClient`
- `src/rmq_middleware/config.py` - добавление настроек Circuit Breaker
- `tests/test_amqp_client.py` - тесты Circuit Breaker

**Критерии завершения:**
- Circuit Breaker автоматически открывается при множественных сбоях
- Метрики состояния Circuit Breaker доступны в Prometheus
- Тесты покрывают все состояния Circuit Breaker

### Задача 1.3: Улучшенная валидация входных данных
**Проблема**: Ограниченная валидация имен AMQP объектов
**Решение**: Строгая валидация по спецификации AMQP

**Шаги реализации:**
1. Исследование спецификации AMQP для имен объектов
2. Создание функций валидации для exchange, queue, routing_key
3. Интеграция валидации в endpoints
4. Добавление тестов для edge cases

**Файлы для изменения:**
- `src/rmq_middleware/security.py` - функции валидации
- `src/rmq_middleware/routes.py` - интеграция валидации
- `tests/test_security.py` - тесты валидации

**Критерии завершения:**
- Отклонение невалидных имен AMQP объектов
- Все тесты валидации проходят
- Документация по форматам имен

## Фаза 2: Улучшение наблюдаемости (2-3 недели)

### Задача 2.1: Расширенные метрики Prometheus
**Проблема**: Ограниченный набор метрик для мониторинга
**Решение**: Добавить метрики latency, error rates, throughput

**Шаги реализации:**
1. Определение ключевых метрик для мониторинга
2. Реализация метрик в `main.py` и `amqp_wrapper.py`
3. Настройка экспорта метрик через Prometheus client
4. Создание Grafana dashboard для визуализации

**Метрики для добавления:**
- `rmq_middleware_publish_duration_seconds` (histogram)
- `rmq_middleware_consume_duration_seconds` (histogram)
- `rmq_middleware_error_total` (counter, по типам ошибок)
- `rmq_middleware_active_connections` (gauge)
- `rmq_middleware_messages_processed_total` (counter)

**Файлы для изменения:**
- `src/rmq_middleware/main.py` - добавление метрик
- `src/rmq_middleware/amqp_wrapper.py` - измерение времени операций
- `grafana/dashboard.json` - создание dashboard

**Критерии завершения:**
- Все метрики доступны в `/metrics`
- Dashboard Grafana отображает ключевые метрики
- Тесты проверяют корректность сбора метрик

### Задача 2.2: Улучшение структурированного логирования
**Проблема**: Неполная информация в логах для диагностики
**Решение**: Расширить контекст логирования

**Шаги реализации:**
1. Добавление дополнительных полей в логи (user_id, exchange, queue)
2. Улучшение формата JSON логов
3. Добавление correlation между логами разных компонентов
4. Настройка ротации и retention логов

**Файлы для изменения:**
- `src/rmq_middleware/middleware.py` - улучшение форматеров
- `src/rmq_middleware/amqp_wrapper.py` - добавление контекста в логи
- `src/rmq_middleware/config.py` - настройки логирования

**Критерии завершения:**
- Логи содержат полный контекст для диагностики
- JSON логи корректно парсятся централизованной системой
- Ротация логов работает корректно

### Задача 2.3: Многоуровневые health checks
**Проблема**: Ограниченные проверки готовности
**Решение**: Добавить проверки диска, памяти, зависимостей

**Шаги реализации:**
1. Создание расширенного health check endpoint
2. Добавление проверок системных ресурсов
3. Интеграция проверок в readiness probe
4. Настройка liveness probe для контейнера

**Файлы для изменения:**
- `src/rmq_middleware/routes.py` - новый endpoint `/health/detailed`
- `src/rmq_middleware/health.py` - модуль health checks
- `docker-compose.yml` - обновление healthcheck

**Критерии завершения:**
- Endpoint `/health/detailed` возвращает полную информацию
- Kubernetes liveness/readiness probes используют новые проверки
- Автоматическое восстановление при проблемах с ресурсами

## Фаза 3: Усиление безопасности (1-2 недели)

### Задача 3.1: Memory encryption для чувствительных данных
**Проблема**: Пароли хранятся в памяти как plain text
**Решение**: Шифрование чувствительных данных в памяти

**Шаги реализации:**
1. Исследование методов шифрования данных в памяти
2. Реализация secure container для хранения паролей
3. Интеграция в `AMQPClient` и `UserSession`
4. Добавление тестов безопасности

**Файлы для изменения:**
- `src/rmq_middleware/security.py` - secure memory container
- `src/rmq_middleware/amqp_wrapper.py` - использование secure container
- `tests/test_security.py` - тесты memory encryption

**Критерии завершения:**
- Пароли не видны в plain text при дампе памяти
- Производительность не деградирует более чем на 5%
- Тесты подтверждают безопасность реализации

### Задача 3.2: Rate limiting по умолчанию
**Проблема**: Отсутствие защиты от DoS атак
**Решение**: Включить rate limiting по умолчанию

**Шаги реализации:**
1. Анализ текущей реализации rate limiting
2. Настройка разумных лимитов по умолчанию
3. Добавление конфигурации для настройки лимитов
4. Интеграция с метриками для мониторинга

**Файлы для изменения:**
- `src/rmq_middleware/security.py` - улучшение rate limiting
- `src/rmq_middleware/config.py` - настройки rate limiting
- `.env.example` - документация настроек

**Критерии завершения:**
- Rate limiting включен по умолчанию
- Метрики отображают rejected requests
- Тесты проверяют корректность работы лимитов

### Задача 3.3: Усиленная валидация AMQP имен
**Проблема**: Возможность инъекции через имена объектов
**Решение**: Строгая валидация по спецификации AMQP 0-9-1

**Шаги реализации:**
1. Изучение спецификации AMQP 0-9-1 для имен объектов
2. Реализация comprehensive валидации
3. Добавление sanitization для потенциально опасных имен
4. Создание allowlist/blocklist для дополнительной защиты

**Файлы для изменения:**
- `src/rmq_middleware/security.py` - расширенная валидация
- `src/rmq_middleware/routes.py` - применение валидации
- `tests/test_security.py` - тесты edge cases

**Критерии завершения:**
- Отклонение всех невалидных имен AMQP объектов
- Защита от инъекций через специальные символы
- Документация по валидным форматам имен

## Фаза 4: Оптимизация производительности (2-3 недели)

### Задача 4.1: Connection pool с health checks
**Проблема**: Потенциальные утечки соединений
**Решение**: Управляемый connection pool с периодическими проверками

**Шаги реализации:**
1. Реализация connection pool с reuse соединений
2. Добавление health checks для соединений в pool
3. Настройка максимального размера pool и timeouts
4. Интеграция с метриками для мониторинга pool

**Файлы для изменения:**
- `src/rmq_middleware/amqp_wrapper.py` - connection pool
- `src/rmq_middleware/config.py` - настройки pool
- `tests/test_amqp_client.py` - тесты pool

**Критерии завершения:**
- Уменьшение времени установления соединений на 50%
- Отсутствие утечек соединений при нагрузке
- Метрики отображают состояние connection pool

### Задача 4.2: Асинхронная обработка больших сообщений
**Проблема**: Блокирование event loop при обработке больших сообщений
**Решение**: Использование thread pool для CPU-intensive операций

**Шаги реализации:**
1. Анализ текущей обработки сообщений
2. Выделение CPU-intensive операций (JSON parsing, encoding)
3. Использование `asyncio.to_thread` или `run_in_executor`
4. Добавление лимитов на размер сообщений

**Файлы для изменения:**
- `src/rmq_middleware/amqp_wrapper.py` - асинхронная обработка
- `src/rmq_middleware/config.py` - лимиты размера сообщений
- `src/rmq_middleware/routes.py` - валидация размера

**Критерии завершения:**
- Отсутствие блокировок event loop при больших сообщениях
- Лимиты размера сообщений работают корректно
- Производительность улучшена на 20% для больших сообщений

### Задача 4.3: Улучшение graceful shutdown
**Проблема**: Потеря сообщений при остановке
**Решение**: Увеличение времени graceful shutdown и draining

**Шаги реализации:**
1. Анализ текущего graceful shutdown
2. Увеличение timeout для завершения операций
3. Реализация draining mode для拒绝 новых запросов
4. Добавление механизма сохранения in-flight сообщений

**Файлы для изменения:**
- `src/rmq_middleware/main.py` - улучшение lifespan
- `src/rmq_middleware/amqp_wrapper.py` - draining mode
- `docker-compose.yml` - настройка stop timeout

**Критерии завершения:**
- Zero message loss при graceful shutdown
- Время остановки не превышает 30 секунд
- Тесты подтверждают сохранение in-flight сообщений

## Фаза 5: Тестирование и документация (1-2 недели)

### Задача 5.1: Нагрузочное тестирование
**Проблема**: Неизвестны пределы производительности
**Решение**: Создание comprehensive нагрузочных тестов

**Шаги реализации:**
1. Разработка сценариев нагрузочного тестирования
2. Использование инструментов (locust, k6, artillery)
3. Определение baseline производительности
4. Выявление bottlenecks и оптимизация

**Файлы для создания:**
- `load_tests/` - директория с нагрузочными тестами
- `scripts/run_load_test.sh` - скрипт запуска тестов
- `docs/performance_benchmarks.md` - документация результатов

**Критерии завершения:**
- Определены пределы производительности системы
- Выявлены и устранены основные bottlenecks
- Документация по scaling рекомендациям

### Задача 5.2: Интеграционные тесты для сценариев сбоев
**Проблема**: Ограниченное тестирование сценариев сбоев
**Решение**: Создание chaos engineering тестов

**Шаги реализации:**
1. Определение критических сценариев сбоев
2. Создание тестов для RabbitMQ недоступности
3. Тестирование network partitions
4. Тестирование восстановления после сбоев

**Файлы для создания:**
- `tests/test_chaos.py` - chaos engineering тесты
- `tests/test_resilience.py` - тесты восстановления
- `scripts/chaos_test.sh` - скрипты chaos testing

**Критерии завершения:**
- Тесты покрывают все критические сценарии сбоев
- Система восстанавливается после всех тестируемых сбоев
- Документация по поведению при сбоях

### Задача 5.3: Обновление документации
**Проблема**: Неполная документация
**Решение**: Comprehensive документация всех аспектов системы

**Шаги реализации:**
1. Обновление README с новой архитектурой
2. Создание runbooks для операционных задач
3. Документация API с примерами
4. Создание troubleshooting guide

**Файлы для создания/обновления:**
- `README.md` - обновленная документация
- `docs/operators_guide.md` - руководство для операторов
- `docs/api_reference.md` - полная документация API
- `docs/troubleshooting.md` - руководство по устранению проблем

**Критерии завершения:**
- Полная документация всех функций системы
- Runbooks для common operational tasks
- API документация с примерами для всех endpoints

## График реализации

```
Неделя 1-2:  Фаза 1 - Критические исправления
Неделя 3-5:  Фаза 2 - Улучшение наблюдаемости  
Неделя 6-7:  Фаза 3 - Усиление безопасности
Неделя 8-10: Фаза 4 - Оптимизация производительности
Неделя 11-12: Фаза 5 - Тестирование и документация
```

## Риски и митигации

### Риск 1: Сложность интеграции Circuit Breaker
**Митигация**: Начать с простой реализации, постепенно усложнять
**Контрольная точка**: После 1 недели реализации

### Риск 2: Производительность при memory encryption
**Митигация**: Прототипирование и benchmarking до полной реализации
**Контрольная точка**: После прототипа в Фазе 3

### Риск 3: Совместимость с существующими клиентами
**Митигация**: Сохранение backward compatibility, feature flags
**Контрольная точка**: Тестирование совместимости в Фазе 5

## Ресурсы

### Команда:
- 1 Senior Backend Engineer (full-time)
- 1 DevOps Engineer (part-time, 50%)
- 1 QA Engineer (part-time, 50%)

### Инфраструктура:
- Тестовый RabbitMQ cluster
- Prometheus/Grafana для мониторинга
- CI/CD pipeline для автоматического тестирования
- Staging environment для нагрузочного