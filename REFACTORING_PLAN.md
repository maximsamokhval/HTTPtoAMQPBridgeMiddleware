# План рефакторинга и развития проекта RMQ Middleware

Этот документ описывает стратегию улучшения архитектуры, производительности и функциональности проекта.

## 1. Анализ текущего состояния кода

### Аудит кодовой базы
*   **Монолитный класс `AMQPClient`**: В файле [amqp_wrapper.py](src/rmq_middleware/amqp_wrapper.py) класс `AMQPClient` нарушает принцип единой ответственности (SRP). Он управляет соединениями, каналами, публикацией, потреблением, топологией и здоровьем системы одновременно. Это "God Object", который сложно поддерживать и тестировать.
*   **Отсутствие Auto-Topology**: Несмотря на упоминание в документации, автоматическое создание Exchange/Queue при публикации или потреблении не реализовано в коде, а присутствует только в тестах.
*   **Rate Limiting In-Memory**: Текущая реализация `RateLimiter` в [security.py](src/rmq_middleware/security.py) хранит состояние в памяти процесса. Это делает невозможным корректное ограничение нагрузки при горизонтальном масштабировании (несколько реплик сервиса).
*   **Синхронная инициализация в Async**: Некоторые части кода могут блокировать event loop, требуется проверка всех I/O операций.
*   **Basic Auth only**: Отсутствует поддержка API Key, заявленная в планах развития.

### Узкие места производительности
*   **Блокировки (Locks)**: Глобальная блокировка `_lock` и `_session_lock` в `AMQPClient` может стать бутылочным горлышком при высокой конкурентности запросов.
*   **Сериализация**: Использование стандартного `json` модуля может быть медленным для больших нагрузок (рассмотреть `orjson`).

### Ключевые модули для рефакторинга
1.  `src/rmq_middleware/amqp_wrapper.py` (Разделение ответственности).
2.  `src/rmq_middleware/security.py` (Вынос Rate Limit в Redis).
3.  `src/rmq_middleware/routes.py` (Упрощение логики за счет новых сервисов).

## 2. Планирование изменений

### Архитектурная схема (Target State)
Вместо одного `AMQPClient` будет внедрена модульная структура:
*   **ConnectionManager**: Отвечает за пул соединений, реконнекты и жизненный цикл сессий.
*   **TopologyManager**: Отвечает за декларацию Exchange, Queue и Bindings (с кэшированием).
*   **PublisherService**: Высокоуровневая логика публикации (валидация -> топология -> отправка).
*   **ConsumerService**: Высокоуровневая логика потребления (получение -> десериализация).
*   **SecurityService**: Аутентификация и Rate Limiting (Redis-based).

### Приоритетные задачи
1.  **Декомпозиция `AMQPClient`** (Высокий приоритет).
2.  **Реализация Auto-Topology** (Высокий приоритет).
3.  **Интеграция Redis для Rate Limiting** (Средний приоритет).
4.  **Внедрение API Key Auth** (Средний приоритет).

### Оценка временных затрат
*   Этап 1 (Core Refactoring): 3-4 дня.
*   Этап 2 (Redis & Security): 2-3 дня.
*   Этап 3 (Cleanup & Docs): 1-2 дня.

## 3. Подготовка инфраструктуры

### CI/CD
*   Настроить GitHub Actions для запуска тестов на ветке `dev`.
*   Добавить шаг линтинга (ruff/mypy) перед тестами.

### Тестовое окружение
*   Использовать `Testcontainers` для RabbitMQ и Redis в интеграционных тестах.
*   Обеспечить изоляцию тестов.

### Мониторинг качества
*   Настроить `pytest-cov` для контроля покрытия кода (цель > 80%).
*   Внедрить `ruff` как основной линтер и форматтер.

## 4. Реализация рефакторинга

### Итерации
1.  **Итерация 1**: Настройка CI, линтеров и создание базовой структуры новых модулей.
2.  **Итерация 2**: Выделение `ConnectionManager` и адаптация тестов.
3.  **Итерация 3**: Реализация `TopologyManager` и внедрение Auto-Topology.
4.  **Итерация 4**: Разделение `Publisher` и `Consumer`.
5.  **Итерация 5**: Интеграция Redis.

### Процесс
*   Каждая итерация оформляется отдельным Pull Request (даже если мы работаем в одной ветке, логически разделять коммиты).
*   Написание unit-тестов для каждого нового класса **до** или **во время** реализации.

## 5. Контроль качества

### Code Review
*   Самостоятельный ревью кода перед коммитом (self-review).
*   Проверка соответствия стилю (PEP 8, Type Hints).

### Метрики
*   Покрытие тестами не должно падать.
*   Отсутствие блокирующих операций в async функциях.
*   Успешное прохождение всех интеграционных сценариев.

### Тестирование
*   Запуск `pytest` после каждого значимого изменения.
*   Ручное тестирование критических сценариев (публикация, потребление, реконнект).
